# -*- coding: utf-8 -*-
"""feature_selection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tNFUapafBz0t4lhy1uZIHBvYjap0Jqwl
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score
from sklearn.naive_bayes import BernoulliNB
import seaborn as sns

df = pd.read_csv('/content/drive/MyDrive/dataset_pre_processed.csv', dtype={"CLASS_LABEL": int})
df.head()

A,B = train_test_split(df, test_size=0.8)

y = A["CLASS_LABEL"]
X = A.drop("CLASS_LABEL", axis=1)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

gbc = svm.SVC()
gbc.fit(X_train,y_train)
pred = gbc.predict(X_test)
f1_score_all = round(f1_score(y_test, pred, average='weighted'),3)

print(f1_score_all)

X_train_v1, X_test_v1, y_train_v1, y_test_v1 = X_train.copy(), X_test.copy(), y_train.copy(), y_test.copy()

"""Feature selection de acordo com importância"""

from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import mutual_info_classif

f1_score_list = []
col = len(df.columns)
for k in range(1, col):
  selector = SelectKBest(mutual_info_classif, k=k)
  selector.fit(X_train_v1, y_train_v1)

  sel_X_train_v1 = selector.transform(X_train_v1)
  sel_X_test_v1 = selector.transform(X_test_v1)

  gbc.fit(sel_X_train_v1,y_train_v1)
  kbests_pred = gbc.predict(sel_X_test_v1)

  f1_score_kbest = round(f1_score(y_test_v1, kbests_pred, average='weighted'),3)
  f1_score_list.append(f1_score_kbest)

bestk = f1_score_list.index(max(f1_score_list))
print(bestk)
print(f1_score_list)

selector = SelectKBest(mutual_info_classif, k=19)
selector.fit(X_train_v1, y_train_v1)

selected_features_mask = selector.get_support()
selected_features = X_train_v1.columns[selected_features_mask]

print(selected_features)

df = df[['NumDots', 'SubdomainLevel', 'PathLevel', 'UrlLength', 'NumDash',
       'NumDashInHostname', 'AtSymbol', 'TildeSymbol', 'NumQueryComponents',
       'NumAmpersand', 'NumNumericChars', 'NoHttps', 'RandomString',
       'IpAddress', 'DomainInSubdomains', 'DomainInPaths', 'HostnameLength',
       'PathLength', 'QueryLength', 'NumSensitiveWords', 'EmbeddedBrandName',
       'PctExtHyperlinks', 'PctExtResourceUrls', 'InsecureForms',
       'AbnormalFormAction', 'PctNullSelfRedirectHyperlinks',
       'FrequentDomainNameMismatch', 'RightClickDisabled', 'PopUpWindow',
       'SubmitInfoToEmail', 'IframeOrFrame', 'ImagesOnlyInForm', 'UrlLengthRT',
       'PctExtResourceUrlsRT', 'AbnormalExtFormActionR', 'ExtMetaScriptLinkRT',
       'PctExtNullSelfRedirectHyperlinksRT']]

# Calculando a matriz de correlação
correlation_matrix = df.corr()

# Gerando o heatmap
plt.figure(figsize=(8, 6))
heatmap = sns.heatmap(correlation_matrix, cmap='coolwarm', vmin=-1, vmax=1)
heatmap.set_xticklabels([])
heatmap.set_yticklabels([])
heatmap.tick_params(left=False, bottom=False)
plt.title("Heatmap de correlação após a seleção de features")
plt.xlabel('Features')
plt.ylabel('Features')
plt.show()